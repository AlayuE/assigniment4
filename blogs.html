<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./css/style.css">
    <link rel="icon" href="./image/link.jpg">
    <title>Blogs</title>
    <!-- <style>/* This is internal style */
        /* ele{
            key:value
        } */
        p{
            color: blue;
        }
    </style> -->
        
</head>
<body>
    <nav id="nav">
        <ul>

         <li><a href="index.html">Home</a></li>
        <li><a href="contact.html">contact</a></li>
        <li><a href="gallary.html">gallary</a></li>
        <li><a href="blogs.html">blogs</a></li>
        <li><a href="myworks.html">my work</a></li>

        </ul>
    </nav>
  
    <div id="cont">
        <!--  -->
        <section class="question">
        <p class="title">Effect of using relative sizes on styling the size of an element</p>
        <article>
            <p>
            Yes, it does matter.
            
            Using dimensions in % or em. Just change the base font size, and everything will change. em is a scalable unit. 
            An em is equal to the current font-size, for instance,if the font-size of the document is 12 pt, 1 em is equal to 12 pt. Ems are 
            scalable in nature,  so 2 em would equal 24 pt,.5 em would equal 6 pt, etc.. Percent (%): The percent unit is much like the 
            “em” unit, save for a few fundamental differences.First and foremost, the current font-size is equal to 100% (i.e. 12 pt = 100%).
            While using the percent unit, the text remains fully scalable for mobile devices and for accessibility.</p>
            <p>   
            rem stands for root em. It's pretty much the same as em, except it will always be relative to the default font size instead of
            the current element's font size. This can either be the default font size of the browser, usually 16px, or one you can set it in 
            your CSS I prefer to use rem for font-sizes, em for margins and paddings and absolute units for borders. 
            </p>
                               
            </p>
        </article>
        <p class="date">march,18,2020 10:03 am</p>
        </section>
        <!-- second post -->
        
            <!-- third post -->
            <section class="question">
                <p class="title">Default browsers width </p>
                <article>
                    <p>
                        The browser interprate this by overriding the default font size of the browser .Setting the font size in pixel values is a good choice when you need pixel accuracy. A px value is static. 
                        This is an OS-independent and cross-browser way of literally telling the browsers to render the letters at exactly
                        the number of pixels in height that is specified. The results may vary slightly across browsers, as they may use different 
                        algorithms to achieve a similar effect.
                        Font sizing settings can also be used in combination. For example, if a parent element is set to 16px and its child element is set to 200px,
                        the child element displays larger than the parent element in the page.
                    </p>
                </article>
                <p class="date">march,18,2020 5:27 pm</p>
                </section>
                <section class="question">
                    <p class="title">New features in Css3</p>
                    <article id="css">
                        <p>CSS3 is the latest evolution of the Cascading Style Sheets language and aims at extending CSS2.1. 
                        It brings a lot of new features  like rounded corners,
                        shadows, gradients, transitions or animations, as well as new layouts like multi-columns, flexible box or grid layouts.</p>
                    <h2>CSS3 Selectors</h2>
                       Selectors are at the heart of CSS. Originally, CSS allowed the matching of elements by type, class, and/or ID. CSS2.1
                        added pseudo-elements,pseudo-classes, and combinators. With CSS3, we can target almost any element on the page with a wide range of 
                        selectors.
                       CSS2 introduced several attribute selectors. These allow for matching elements based on their attributes. 
                       CSS3 expands upon those attribute selectors.Three more attribute selectors were added in CSS3; they allow for substring selection.
                       1.Matches any element E whose attribute attr starts with the value val. In other words, the val matches the beginning of the attribute value.
                       2.Matches any element E whose attribute attr ends in val. In other words, the val matches the end of the attribute value.
                       3.Matches any element E whose attribute attr matches val anywhere within the attribute. 

                       <h2>Pseudo-classes</h2>
                       It’s likely that you’re already familiar with some of the user interaction pseudo-classes,namely :link, :visited, :hover, :active, and :focus.
                       A few more pseudo-class selectors were added in CSS3. One is the :root selector, which allows designers to point to the root element of a 
                       document. In HTML, it would be . Since :root is generic, it allows a designer to select the root element of an XML document without 
                        necessarily knowing it’s name. To permit scrollbars when needed in a document, this rule would work.
                       As a complement to the :first-child selector, the :last-child was added. With it one can select the last element named of a parent element.

                       A new user interaction pseudo-class selector was added, the :target selector. To draw the user’s attention to a span of text when the user 
                       clicks on a same-page link, a rule like the first line below would work nicely; the link would look like the second line, the highlighted span like the third.
        
                       A functional notation for selecting specified elements that fail a test has been created. The negation pseudo-class selector, :not can be 
                       coupled with almost any other selector that has been implemented. For example to put a border around images that don’t have a border 
            
                       <h2>CSS3 Colors</h2>
                       CSS3 brings with it support for some new ways of describing colours . Prior to CSS3, we almost always declared colours using the hexadecimal
                        format (#FFF, or #FFFFFF for white). It was also possible to declare colours using the rgb() notation, providing either integers (0–255) or
                         percentages.
                       The color keyword list has been extended in the CSS3 color module to include 147 additional keyword colors (that are generally well supported), CSS3 also provides us with a number of other options: HSL, HSLA, and RGBA. The most notable change with these new color types is the ability to declare semitransparent colors.
                       <h3>RGBA </h3>
                       RGBA works just like RGB, except that it adds a fourth value: alpha, the opacity level or alpha transparency level. The first three values 
                       still represent red, green, and blue. For the alpha value, 1 means fully opaque, 0 is fully transparent, and 0.5 is 50% opaque. You can use 
                       any number between 0 and 1 inclusively.
                        <h3>HSL and HSLA</h3>
                       HSL stands for hue, saturation, and lightness. Unlike RGB, where you need to manipulate the saturation or brightness of a color by changing 
                       all three color values in concert, with HSL you can tweak either just the saturation or the lightness while keeping the same base hue. The 
                       syntax for HSL comprises an integer value for hue, and percentage values for saturation and lightness.
                       The hsl( ) declaration accepts three values:
                       The hue in degrees from 0 to 359. Some examples are: 0 = red, 60 = yellow, 120= green, 180 = cyan, 240 = blue, and 300 = magenta.
                       The saturation as a percentage with 100% being the norm. Saturation of 100% will be the full hue, and saturation of 0 will give you a shade
                        of gray — essentially causing the hue value to be ignored.
                       A percentage for lightness with 50% being the norm. A lightness of 100% will be white, 50% will be the actual hue, and 0% will be black.
                       The a in hsla( ) here also functions the same way as in rgba( ).</p>
                       <h2>Opacity</h2>
                       <p>In addition to specifying transparency with HSLA and RGBA colors (and soon, eight-digit hexadecimal values), CSS3 provides us with the 
                       opacity property. opacity sets the opaqueness of the element on which it’s declared, similar to alpha.
                       Though the usage of both alpha and opacity notations seem similar, when you look at it, there is a key difference in their function.
                       While opacity sets the opacity value for an element and all of its children, a semitransparent RGBA or HSLA color has no impact on the
                        element’s other CSS properties or descendants.</p>

                       <h2>Rounded Corners: border-radius</h2>
                       <p>The border-radius property lets you create rounded corners without the need for images or additional markup. To add rounded corners to our
                        box, we simply add The border-radius property is actually a shorthand. For our “a” element, the corners are all the same size and symmetrical. If we had wanted
                        different-sized corners, we could declare up to four unique values.</p>

                       <h2>Drop Shadows</h2>
                       <p>CSS3 provides the ability to add drop shadows to elements using the box-shadow property. This property lets you specify the color, height, 
                       width, blur, and offset of one or multiple inner and/or outer drop shadows on your elements.</p>

                        <h2>Text Shadow</h2>
                        <p>Text-shadow adds shadows to individual characters in text nodes. Prior to CSS 3, this would be done by either using an image or duplicating
                        a text element and then positioning it.</p>

                       <h2>Radial Gradients</h2>
                       <p>Radial gradients are circular or elliptical gradients. Rather than proceeding along a straight axis, colors blend out from a starting point
                        in all directions.</p>
                      
                       <h2>Multiple Background Images</h2>
                      <p>In CSS3, there’s no need to include an element for every background image; it provides us with the ability to add more than one background 
                       image to any element, even to pseudo-elements.</p>
                        
                    </article>
                    <p class="date">march,19,2020 8:49 am</p>
                    </section>
    
</body>
</html>